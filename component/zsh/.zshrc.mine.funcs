## functions
#


##############################################################################
# 内部使用関数
##############################################################################

# カレントディレクトリ以下をfindして選択した通常ファイルを返す
#   $1 : findするパス
#   $2 : findコマンドに渡す maxdepth
#   $3 : findコマンドに渡す type
#   $4 : .で始まる物を無視するかどうか 省略した場合は含む、何か指定した場合は含まない
peco-findselect() {
    local base_path="$1"
    local max_depth="$2"
    local find_type="$3"

    if [ -n "$4" ]; then
        local file=`find ${base_path} -maxdepth ${max_depth} -type ${find_type} ! -path "*/.*" 2>/dev/null | peco`
    else
        local file=`find ${base_path} -maxdepth ${max_depth} -type ${find_type} 2>/dev/null | peco`
    fi
    echo $file
}


# 指定したプログラムを開く
# ZLEを使用するので 'zle -N ...', 'bindkey ...' をしてから使うこと
#   $1 : 開きたいプログラムのコマンド
#   $2 : プログラムに渡すコマンド
open_command() {
    BUFFER="$1 $2"
    CURSOR=$#BUFFER
    zle accept-line
}


# findで検索した結果をpecoで選択して指定したプログラムを開く
# ZLEを使用するので 'zle -N ...', 'bindkey ...' をしてから使うこと
#   $1 : 開きたいプログラムのコマンド
peco_find_open_command() {
    local file="$(peco-findselect . 5 f)"
    if [ -n "${file}" ]; then
        open_command $1 ${file}
    fi
}



##############################################################################
# キーバインド無しの関数
##############################################################################

# "up"コマンドは、ディレクトリ階層を非常に簡単に上れるようにする為のコマンドです。
# "up"コマンドを単体で利用した場合、「cd ../」コマンドと同一です。
# "up 2"のように、引数に数値を与えて実行した場合、その階層分だけ上に移動する事ができます。
# By https://github.com/m-yamashita/up
function up(){
    cpath=./
    for i in `seq 1 1 $1`; do
        cpath=$cpath../
    done
    cd $cpath
}


# プロセスのkill
# By http://k0kubun.hatenablog.com/entry/2014/07/06/033336
function peco-pkill() {
    for pid in `ps aux | peco | awk '{ print $2 }'`; do
        kill $pid
        echo "Killed ${pid}"
    done
}
alias pk="peco-pkill"


##############################################################################
# キーバインド付きの関数
##############################################################################

#
# historyからの絞り込み実行
# By http://k0kubun.hatenablog.com/entry/2014/07/06/033336
#
function peco-select-history() {
    typeset tac
    if which tac > /dev/null; then
        tac=tac
    else
        tac='tail -r'
    fi
    BUFFER=$(fc -l -n 1 | eval $tac | peco --query "$LBUFFER")
    CURSOR=$#BUFFER
    zle redisplay
}
zle -N peco-select-history
bindkey '^h' peco-select-history


#
# 汎用ディレクトリ選択
# By http://qiita.com/ymorired/items/4b0d8e95786efc1378b4
#
function peco-findcd() {
    # .で始まるディレクトリは除外してカレントから5階層下までリスティング
    local selected_dir="$(peco-findselect . 5 d true)"
    if [ -d "$selected_dir" ]; then
        BUFFER="cd \"${selected_dir}\""
        CURSOR=$#BUFFER
        zle accept-line
    fi
    zle clear-screen
 }
zle -N peco-findcd
bindkey '^c^d' peco-findcd


#
# カレントディレクトリ以下をfindして選択したファイルをvimで開く
#
function peco-findvim() {
    peco_find_open_command "vim"
}
zle -N peco-findvim
bindkey '^v^i' peco-findvim


#
# カレントディレクトリ以下をfindして選択したファイルをgVIM(Macの場合はMacVIM)で開く
#
function peco-findmacvim() {
    local GVIM_PATH="/Applications/MacVIM.app"
    peco_find_open_command "open -a ${GVIM_PATH}"
}
zle -N peco-findmacvim
bindkey '^g^v' peco-findmacvim


#
# カレントディレクトリ以下をfindして選択したファイルをcotで開く
#
function peco-findcot() {
    local COT_PATH="/Applications/CotEditor.app"
    peco_find_open_command "open -a ${COT_PATH}"
}
zle -N peco-findcot
bindkey '^p^o' peco-findcot


#
# 'cd ..' する
#
function cd_up() {
    cd ..
    zle reset-prompt
}
zle -N cd_up
# bindkey '^f' vi-kill-line # デフォルトのキーバインド(^U)を変更
# bindkey '^u' cd_up


#
# viキーバインド上でコマンドラインスタックを実行(Ctrl+Q)する
#
show_buffer_stack() {
    POSTDISPLAY="
    stack: $LBUFFER"
    zle push-line-or-edit
}
zle -N show_buffer_stack
setopt noflowcontrol
bindkey '^q' show_buffer_stack


#
# 'git status'した結果を選択してカーソル位置に挿入(複数選択可)
#
function peco_insert_selected_git_files() {
    LBUFFER+=$(git status --porcelain | peco | awk -F ' ' '{print $NF}' | tr '\n' ' ')
    CURSOR=$#LBUFFER
    zle reset-prompt
}
zle -N peco_insert_selected_git_files
bindkey "^g^s" peco_insert_selected_git_files

#
# agした結果をpecoで選択してvimで開く
#
function agvim() {
  vim $(ag "$@" | peco --query "$LBUFFER" | awk -F : '{print "-c " $2 " " $1}')
}


##############################################################################
# for Git
##############################################################################

# develop をマージ
function update_develop() {
	git fetch && git checkout develop && git rebase origin/develop
}

# gitの全ブランチ一覧を表示して選択したブランチにチェックアウト
function _git_checkout() {
    local selectted_branch="$(git branch -a --sort=-authordate | perl -pe 's#^remotes/origin/###' | peco)"
    git checkout ${selectted_branch##* }
}

# gitのローカルブランチ一覧を表示して選択したブランチにチェックアウト
function _git_checkout_local() {
    local selectted_branch="$(git branch | peco)"
    git checkout ${selectted_branch##* }
}

# gitのリモートブランチ一覧を表示して選択したブランチにチェックアウト
function _git_checkout_remote() {
    local selectted_branch="$(git branch -r --sort=-authordate | perl -pe 's#origin/###' | peco)"
    git checkout ${selectted_branch##* }
}

# git diff を補完
#  -s : peco ファイルを選択して diff をとる
#  -a : 全 diff を表示
function _git_diff() {
  case $1 in
	-s)
	  local selected_file="$(g lm | peco)"
	  if [ ! -z ${selected_file} ]; then
	  	git diff ${selected_file}
	  	echo -n "\nAdd ${selected_file} to staging? "; read answer
	  	  case $answer in
	    	[yY] | [yY]es | YES )
	          _git_add ${selected_file};;
	      	* )
	      	  echo "No actions."
	      	  return 1;;
	 	  esac
	  else
	  	echo "No selected for diff."
	  fi
	  ;;
	-a)
	  git diff .
	  ;;
	'')
	  echo "No actions."
	  ;;
	*)
	  git diff $1

	  echo -n "\nAdd {$1} to staging? "; read answer
	  case $answer in
	    [yY] | [yY]es | YES )
	      _git_add $1;;
	    * )
	      echo "No actions."
	      return 1;;
	  esac
	  ;;
  esac	
}

# git add を補完
function _git_add() {
  case $1 in
	-s)
	  local selected_file="$(g lm | peco)"
	  if [ ! -z ${selected_file} ]; then
	  	git add $2 ${selected_file}
	  else
	    echo "No selected for add."
	  fi
	  ;;
	-a)
	  git add .
	  ;;
	-u)
	  local selected_file="$(g lu | peco)"
	  if [ ! -z ${selected_file} ]; then
	    git add $2 ${selected_file}
	  else
	    echo "No selected for add."
	  fi
	  ;;
	'')
	  echo "No selected."
	  ;;
	*)
	  git add $1
	  ;;
  esac
}

# git restore を補完
function _git_restore() {
  case $1 in
	-s)
	  local selected_file="$(g dn --staged | peco)"
	  if [ ! -z ${selected_file} ]; then
	    git restore --staged ${selected_file}
	  else
	    echo "No selected for restore."
	  fi
	  ;;
	-a)
	  git reset HEAD
	  ;;
	'')
	  echo "No actions."
	  ;;
	*)
	  git restore --staged $1
	  ;;
  esac
}

# git checkout <file> を補完
function _git_discard_diff() {
  case $1 in
	-s)
	  local selected_file="$(g lm | peco)"
	  if [ ! -z ${selected_file} ]; then
	    echo -n "Really discard ${selected_file} changes? "; read answer
	  	  case $answer in
	    	[yY] | [yY]es | YES )
	          git checkout ${selected_file##* };;
	      	* )
	      	  echo "No actions."
	      	  return 1;;
	 	  esac
	  else
	    echo "No selected for discard."
	  fi
	  ;;
	-a)
	  echo -n "Really discard all changes? "; read answer
	  case $answer in
	    [yY] | [yY]es | YES )
	      git reset --hard HEAD;;
	    * )
	      echo "No actions."
	      return 1;;
	  esac
	  ;;
	'')
	  echo "No selected file to discard changes."
	  ;;
	*)
	  git checkout $1
	  ;;
  esac
}

# 今のブランチを origin に push
function _git_push_current_branch() {
  local checkouted="$(g b --show-current)"
  echo -n "Really push to origin/${checkouted}? "; read answer
  case $answer in
  	[yY] | [yY]es | YES )
  	  git push origin $(g b --show-current);;
  	* )
  	  echo "No actions."
  	  return 1;;
  esac
}

# peco で選択したブランチに origin から pull してくる
function _git_pull() {
    local selectted_branch="$(git branch | peco)"
    git fetch && git checkout ${selectted_branch##* } && git rebase origin/${selectted_branch##* }
}
